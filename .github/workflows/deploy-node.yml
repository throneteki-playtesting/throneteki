name: Deploy Game Nodes
on:
    workflow_dispatch:
        inputs:
            environment:
                type: environment
                description: Select the environment
                default: Production

jobs:
    deploy:
        runs-on: self-hosted
        environment: ${{ inputs.environment }}
        steps:
            - name: Checkout repo
              uses: actions/checkout@v3

            - name: Deploy Game Nodes
              run: |
                  # Determine namespace and replicas based on environment
                  ENV=$(echo "${{ github.event.inputs.environment }}" | tr '[:upper:]' '[:lower:]')

                  if [ "${{ github.event.inputs.environment }}" = "Production" ]; then
                    NAMESPACE="throneteki"
                    REPLICAS=2
                    ENV_SUBDOMAIN="production"
                  elif [ "${{ github.event.inputs.environment }}" = "Development" ]; then
                    NAMESPACE="throneteki-development"
                    REPLICAS=1
                    ENV_SUBDOMAIN="dev"
                  elif [ "${{ github.event.inputs.environment }}" = "Playtesting" ]; then
                    NAMESPACE="throneteki-playtesting"
                    REPLICAS=1
                    ENV_SUBDOMAIN="playtesting"
                  else
                    NAMESPACE="throneteki-$ENV"
                    REPLICAS=1
                    ENV_SUBDOMAIN="$ENV"
                  fi

                  echo "Deploying to namespace: $NAMESPACE with $REPLICAS replicas for environment: $ENV_SUBDOMAIN"

                  # Generate a unique deployment timestamp to force pod updates
                  DEPLOY_TIME=$(date +%s)
                  echo "Deployment timestamp: $DEPLOY_TIME"

                  # Get current replica count before deployment
                  CURRENT_REPLICAS=$(kubectl get statefulset node -n $NAMESPACE -o jsonpath='{.spec.replicas}' 2>/dev/null || echo "0")
                  echo "Current replicas: $CURRENT_REPLICAS"

                  # Calculate temporary replica count for zero-downtime deployment
                  if [ "$CURRENT_REPLICAS" = "0" ]; then
                    # First deployment - just deploy normally
                    TEMP_REPLICAS=$REPLICAS
                  else
                    # Scale up to have both old and new pods
                    TEMP_REPLICAS=$((CURRENT_REPLICAS + REPLICAS))
                  fi

                  echo "Will deploy with $TEMP_REPLICAS replicas, then scale to $REPLICAS"

                  # Create values file with secrets
                  cat > /tmp/node-secrets.yaml <<EOF
                  nodeConfig:
                    env: "${{ vars.NODE_ENV || 'production' }}"
                    instance:
                      type: "$ENV"
                    sentryDsn: "${{ secrets.SENTRY_DSN }}"
                    dbPath: "${{ secrets.DB_PATH }}"
                    redisPrefix: "$ENV"
                    redisUrl: "${{ secrets.REDIS_URL }}"
                    secret: "${{ secrets.SECRET }}"
                    hmacSecret: "${{ secrets.HMAC_SECRET }}"
                    lobbyUrl: "${{ vars.LOBBY_URL }}"
                    socketioPort: 80
                  EOF

                  # Deploy with temporary higher replica count
                  helm upgrade --install game-node ./infrastructure/node \
                    --set namespace=$NAMESPACE \
                    --set replicaCount=$TEMP_REPLICAS \
                    --set environment=$ENV_SUBDOMAIN \
                    --set deployTime=$DEPLOY_TIME \
                    -f /tmp/node-secrets.yaml \
                    -n $NAMESPACE

                  # Clean up secrets file
                  rm /tmp/node-secrets.yaml

                  if [ "$CURRENT_REPLICAS" != "0" ]; then
                    # Wait for new pods to be ready
                    echo "Waiting for new pods to be ready..."
                    for i in $(seq $CURRENT_REPLICAS $((TEMP_REPLICAS - 1))); do
                      kubectl wait --for=condition=ready pod/node-$i -n $NAMESPACE --timeout=5m || true
                    done

                    # Delete old pods (they will drain gracefully)
                    echo "Deleting old pods to trigger graceful draining..."
                    for i in $(seq 0 $((CURRENT_REPLICAS - 1))); do
                      echo "Deleting node-$i..."
                      kubectl delete pod node-$i -n $NAMESPACE --wait=false
                    done

                    # Give old pods time to enter draining state
                    echo "Waiting for old pods to start draining..."
                    sleep 15

                    # Scale down to desired replica count
                    # This will keep the higher-numbered (newer) pods
                    echo "Scaling to final replica count: $REPLICAS"
                    kubectl patch statefulset node -n $NAMESPACE -p "{\"spec\":{\"replicas\":$REPLICAS}}"
                  fi

                  # Wait for final state
                  kubectl rollout status statefulset/node -n $NAMESPACE --timeout=120m
